#!/usr/bin/env python
# coding: utf-8

""" landcover_classif.py: Land cover classification with machine learning (random forest)
Eduardo Jimenez <eduardojh@email.arizona.edu>

  Sep 16, 2022: Ported from San Juan River script.
  Jan 13, 2023: Modified for Calakmul Biosphere Reserve (local machine).
  Feb 21, 2023: Updated to use sample mask generated by stratified random sampling (moved to '01_sample_mask.py').
  May  1, 2023: RF runs with HDF5 data but needs tunning for accurate predictions.

NOTE: run under 'rsml' conda environment (python 3.8.13, scikit-learn 1.1.2)
"""
import sys
import pickle
import csv
import h5py
import numpy as np
import pandas as pd
import matplotlib as mpl
import matplotlib.pyplot as plt
from datetime import datetime

from sklearn.ensemble import RandomForestClassifier
# from sklearn.datasets import make_classification
# from skimage import data, color, io, img_as_float
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report

if len(sys.argv) == 3:
    # Check if arguments were passed from terminal
    args = sys.argv[1:]
    sys.path.insert(0, args[0])
    cwd = args[1]
    print(f"  Using RS_LIB={args[0]}")
    print(f"  Using CWD={args[1]}")
else:
    import os
    import platform
    system = platform.system()
    if system == 'Windows':
        # On Windows 10
        sys.path.insert(0, 'D:/Desktop/land_cover_analysis/lib/')
        cwd = 'D:/Desktop/CALAKMUL/ROI1/'
    elif system == 'Linux' and os.path.isdir('/vipdata/2023/CALAKMUL/ROI1/'):
        # On Ubuntu Workstation
        sys.path.insert(0, '/vipdata/2023/land_cover_analysis/lib/')
        cwd = '/vipdata/2023/CALAKMUL/ROI1/'
    elif system == 'Linux' and os.path.isdir('/VIP/engr-didan02s/DATA/EDUARDO/ML/'):
        # On Alma Linux Server
        sys.path.insert(0, '/home/eduardojh/Documents/land_cover_analysis/lib/')
        cwd = '/VIP/engr-didan02s/DATA/EDUARDO/ML/'
    else:
        print('  System not yet configured!')

import rsmodule as rs

fmt = '%Y_%m_%d-%H_%M_%S'
start = datetime.now()

def read_features(filename: str, indices: dict, rows_arr: int, cols_arr: int, bands_arr: int) -> np.ndarray:
    """ Reads features from HDF5 file using its corresponding index, returns a 2D array ready for RF """
    
    x = np.empty((rows,cols,bands), dtype=np.int16)  ### TODO: CAUTION! This cast all values into integers!!!

    with h5py.File(filename, 'r') as fx:
        # Get the data from the HDF5 files
        for key in list(indices.keys()):
            dataset = indices[key]
            x[:,:,key] = fx[dataset][:]

    # Reshape x_train into a 2D-array of dimensions: (rows*cols, bands)
    x_temp = x.copy()
    x = np.empty((rows_arr*cols_arr,bands_arr), dtype=np.int16)
    i = 0
    for row in range(rows):
        for col in range(cols):
            # print(f'row={row}, col={col}: {X_temp[:,row,col]} {X_temp[:,row,col].shape}')
            # if row%500 == 0 and col%100 == 0:
            #     print(f'{i} row={row}, col={col}: {x_temp[row, col,:]} {x_temp[row, col,:].shape}')
            # Place all bands from a pixel into a row
            x[i,:] = x_temp[row, col,:]
            i += 1
    return x


def land_cover_conf_table(fn_table, n_classes, **kwargs):
    """ Plots a land cover confussion table """
    _normalize = kwargs.get('normalize', False)
    _title = kwargs.get('title', '')
    _savefig = kwargs.get('savefig', '')
    _dpi = kwargs.get('dpi', 300)

    values = np.array(pd.read_csv(fn_table, header=None))
    if _normalize:
        values = (values - np.min(values)) / (np.max(values) - np.min(values))

    land_cover = [x for x in range(0, n_classes)]

    fig, ax = plt.subplots(figsize=(12,12))
    im = ax.imshow(values)

    # Show all ticks and label them with the respective list entries
    ax.set_xticks(np.arange(len(land_cover)), labels=land_cover)
    ax.set_yticks(np.arange(len(land_cover)), labels=land_cover)
    ax.grid(False)

    # Loop over data dimensions and create text annotations.
    for i in range(len(land_cover)):
        for j in range(len(land_cover)):
            if _normalize:
                text = ax.text(j, i, f'{values[i, j]:0.2f}', ha="center", va="center", color="w", fontsize='x-small')
            else:
                text = ax.text(j, i, f'{values[i, j]:0.0f}', ha="center", va="center", color="w", fontsize='x-small')
            
    if _title != '':
        ax.set_title(_title)
    if _savefig != '':
        plt.savefig(_savefig, bbox_inches='tight', dpi=_dpi)
    else:
        plt.show()
    plt.close()

# fn_landcover = cwd + 'data/inegi_2018//usv250s7cw_ROI1_LC_KEY.tif'        # Land cover raster
fn_landcover = cwd + 'data/inegi_2018/land_cover_ROI1.tif'      # Groups of land cover classes w/ancillary
fn_features = cwd + 'features/season/Calakmul_Features_season.h5'
fn_train_feat = cwd + 'features/season/Calakmul_Training_Features_season.h5'
fn_test_feat = cwd + 'features/season/Calakmul_Testing_Features_season.h5'
fn_labels = cwd + 'features/Calakmul_Labels.h5'
fn_feat_indices = cwd + 'features/season/feature_indices_season.csv'
fn_parameters = cwd + 'features/season/dataset_parameters_season.csv'
# fn_colormap = cwd + 'parameters/qgis_cmap_landcover_CBR_viri.clr'  # not grouped
fn_colormap = cwd + 'parameters/qgis_cmap_landcover_CBR_viri_08grp.clr'

# File names to save results and reports
save_train_plot = cwd + f'results/{datetime.strftime(start, fmt)}_rf_training_plot.png'
save_train_stats = cwd + f'results/{datetime.strftime(start, fmt)}_rf_training_stats.csv'
save_conf_tbl = cwd + f'results/{datetime.strftime(start, fmt)}_rf_confussion_table.csv'
save_crosstab_train = cwd + f'results/{datetime.strftime(start, fmt)}_rf_crosstab_train.csv'
save_crosstab_test = cwd + f'results/{datetime.strftime(start, fmt)}_rf_crosstab_test.csv'
save_model = cwd + f'results/{datetime.strftime(start, fmt)}_rf_model.pkl'
save_report = cwd + f'results/{datetime.strftime(start, fmt)}_rf_classif_report.txt'
save_preds_raster = cwd + f'results/{datetime.strftime(start, fmt)}_rf_predictions.tif'
save_preds_fig = cwd + f'results/{datetime.strftime(start, fmt)}_rf_predictions.png'
save_params = cwd + f'results/{datetime.strftime(start, fmt)}_rf_parameters.csv'

# Read the parameters saved from previous script to ensure matching
parameters = rs.read_params(fn_parameters)
# print(parameters)
rows, cols = int(parameters['ROWS']), int(parameters['COLUMNS'])
n_classes = int(parameters['NUM_CLASSES'])
bands = int(parameters['LAYERS'])

# Read the feature indices
feat_index = {}
with open(fn_feat_indices, 'r',) as csv_file:
    reader = csv.reader(csv_file, delimiter=',')
    for row in reader:
        if len(row) == 0:
            continue
        feat_index[int(row[0])] = row[1]
print(f"Running RF with {len(feat_index)} features.")
for key in feat_index.keys():
    print(f"{key:>2} {feat_index[key]}")

x_train = np.empty((rows,cols,bands), dtype=np.int16)
y_train = np.empty((rows,cols), dtype=np.uint8)
x_test = np.empty((rows,cols,bands), dtype=np.int16)
y_test = np.empty((rows,cols), dtype=np.uint8)
test_mask = np.empty((rows,cols), dtype=np.uint8)
train_mask = np.empty((rows,cols), dtype=np.uint8)

### Read the labels and features
print("Reading features and labels...")
with h5py.File(fn_labels, 'r') as fy:
    y_train = fy['training'][:]
    y_test = fy['testing'][:]
    test_mask = fy['test_mask'][:]
    train_mask = fy['train_mask'][:]
train_mask = train_mask.flatten()
test_mask = test_mask.flatten()

x_train = read_features(fn_train_feat, feat_index, rows, cols, bands)
y_train = y_train.flatten()  # flatten by appending rows, each value will correspod to a row in x_train

# x_train = x_train[train_mask > 0]
# y_train = y_train[train_mask > 0]

print(f'  --x_train shape={x_train.shape}')
print(f'  --y_train shape={y_train.shape}')

# Now read test features and labels
x_test = read_features(fn_test_feat, feat_index, rows, cols, bands)
y_test = y_test.flatten() # flatten by appending rows

# x_test = x_test[test_mask > 0]
# y_test = y_test[test_mask > 0]

print(f'  --x_test shape={x_test.shape}')
print(f'  --y_test shape={y_test.shape}')

tr_lbl, tr_fq = np.unique(train_mask, return_counts=True)
ts_lbl, ts_fq = np.unique(test_mask, return_counts=True)
df_mask = pd.DataFrame({'TrVal': tr_lbl, 'TrFq': tr_fq, 'TsVal': ts_lbl, 'TsFq': ts_fq})
# df_mask['Total'] = df_mask['TrFq'] + df_mask['TsFq']
df_mask.loc['Total'] = df_mask.sum(numeric_only=True, axis=0)
print(df_mask)

# Check labels between train and test are the same
tr_lbl, tr_fq = np.unique(y_train, return_counts=True)
ts_lbl, ts_fq = np.unique(y_test, return_counts=True)
print(tr_lbl, ts_lbl)
# assert len(tr_lbl) == len(ts_lbl), "Train and test labels do not match!"
df = pd.DataFrame({'TrainLbl': tr_lbl, 'TrainFreq': tr_fq, 'TestLbl': ts_lbl, 'TestFreq': ts_fq})
# df['Total'] = df['TrainFreq'] + df['TestFreq']
df.loc['Total'] = df.sum(numeric_only=True, axis=0)
print(df)


### TRAIN THE RANDOM FOREST
print(f'  {datetime.strftime(datetime.now(), fmt)}: starting Random Forest training')

# Random forest
print('  Creating the model')
start_train = datetime.now()

rf_trees = 50
rf_depth = None
rf_jobs = 3
# class_weight = {class_label: weight}

rf = RandomForestClassifier(n_estimators=rf_trees,
                            oob_score=True,
                            max_depth=rf_depth,
                            n_jobs=rf_jobs,
                            verbose=1)

print(f'  {datetime.strftime(datetime.now(), fmt)}: fitting the model...')
rf = rf.fit(x_train, y_train)

# Save trained model
# with open(save_model, 'wb') as f:
#     pickle.dump(rf, f)

print(f'  --OOB prediction of accuracy: {rf.oob_score_ * 100:0.2f}%')

for b, imp in zip(feat_index.keys(), rf.feature_importances_):
    print(f'  --Band {feat_index[b]:>15} importance: {imp}')

# A crosstabulation to see class confusion for TRAINING
y_pred_train = rf.predict(x_train)
df = pd.DataFrame()
df['truth_train'] = y_train
df['predict_train'] = y_pred_train
crosstab = pd.crosstab(df['truth_train'], df['predict_train'], margins=True)
crosstab.to_csv(save_crosstab_train)

end_train = datetime.now()
training_time = end_train - start_train
print(f'  {datetime.strftime(datetime.now(), fmt)}: training finished in {training_time}.')

# Predict on the rest of the image, using the fitted Random Forest classifier
print(f'  {datetime.strftime(datetime.now(), fmt)}: making predictions')
start_pred = datetime.now()
y_pred = rf.predict(x_test)
print(f'  --y_pred shape:', y_pred.shape)

# A crosstabulation to see class confusion for TESTING
df['truth_test'] = y_test
df['predict_test'] = y_pred
crosstab2 = pd.crosstab(df['truth_test'], df['predict_test'], margins=True)
crosstab2.to_csv(save_crosstab_test)

# # USE MASK: Evaluate on the valid region only (discard NoData pixels)
# y_test = np.where(y_test_mask == 1, y_test, 0)
# y_pred = np.where(y_test_mask == 1, y_pred, 0)

# # A crosstabulation to see class confusion for TESTING MASKED
# df['truth_test_mask'] = y_test
# df['predict_test_mask'] = y_pred
# crosstab3 = pd.crosstab(df['truth_test_mask'], df['predict_test_mask'], margins=True)
# crosstab3.to_csv(save_crosstab_train[:-4] + '_mask.csv')

accuracy = accuracy_score(y_test, y_pred)
print(f'  --Accuracy score: {accuracy}')

cm = confusion_matrix(y_test, y_pred)
# print('Confusion matrix:')
# print(type(cm))
# print(cm.shape)
with open(save_conf_tbl, 'w') as csv_file:
    writer = csv.writer(csv_file, delimiter=',')
    for single_row in cm:
        writer.writerow(single_row)
        # print(single_row)

report = classification_report(y_test, y_pred, )
print('  Classification report')
print(report)
with open(save_report, 'w') as f:
    f.write(report)

end_pred = datetime.now()
pred_time = end_pred - start_pred
print(f'  {datetime.strftime(datetime.now(), fmt)}: prediction finished in {pred_time}')

# Reshape the classification map into a 2D array again to show as a map
y_pred = y_pred.reshape((rows,cols))
y_pred_train = y_pred_train.reshape((rows,cols))
# Put together testing and training predictions into a single array
pred_map = np.where(test_mask == 1, y_pred, y_pred_train)

print(f'  --y_pred (re)shape:', y_pred.shape)
print(f'  --y_pred_train (re)shape:', y_pred_train.shape)
print(f'  --pred_map shape:', pred_map.shape)

print(f"  --Pred train: {np.unique(y_pred_train)}")
print(f"  --Pred test: {np.unique(y_pred)}")
print(f"  --Pred all: {np.unique(pred_map)}")

# Plot the land cover map of the predictions for y and the whole area
rs.plot_array_clr(y_pred, fn_colormap, savefig=save_preds_fig, zero=True)  # zero=True, zeros removed with mask?
rs.plot_array_clr(y_pred_train, fn_colormap, savefig=save_preds_fig[:-4]+'_train.png', zero=True)
rs.plot_array_clr(pred_map, fn_colormap, savefig=save_preds_fig[:-4]+'_all.png', zero=True)

# Save GeoTIFF of the predicted land cover classes
epsg_proj = int(parameters['EPSG'])
txt = parameters[' GEOTRANSFORM'].replace('(', '').replace(')', '')
gt = [float(x) for x in txt.split(',')]

rs.create_raster(save_preds_raster, y_pred, epsg_proj, gt)
rs.create_raster(save_preds_raster[:-4]+'_train.tif', y_pred_train, epsg_proj, gt)
rs.create_raster(save_preds_raster[:-4]+'_all.tif', pred_map, epsg_proj, gt)

with open(save_params, 'w') as csv_file:
    writer = csv.writer(csv_file, delimiter=',')
    writer.writerow(['Parameter', 'Value'])
    writer.writerow(['Start', start])
    writer.writerow(['CWD', cwd])
    writer.writerow(['Format', fmt])
    writer.writerow(['x_train shape', f'{x_train.shape}'])
    writer.writerow(['y_train shape', f'{y_train.shape}'])
    writer.writerow(['x_test shape', f'{x_test.shape}'])
    writer.writerow(['y_test shape', f'{y_test.shape}'])
    writer.writerow(['MODEL:', 'RandomForestClassifier'])
    writer.writerow([' Estimators', rf_trees])
    writer.writerow([' Max depth', rf_depth])
    writer.writerow([' Jobs', rf_jobs])
    writer.writerow([' OOB prediction of accuracy', f'{rf.oob_score_}' ])
    writer.writerow([' Accuracy score', f'{accuracy}' ])
    writer.writerow([' Start training', f'{start_train}'])
    writer.writerow([' End training', f'{end_train}'])
    writer.writerow([' Training time', f'{training_time}'])
    writer.writerow([' Start testing (prediction)', start_pred])
    writer.writerow([' End testing (prediction)', end_pred])
    writer.writerow([' Testing time (prediction)', pred_time])

# Plot the confusion table
land_cover_conf_table(save_conf_tbl, n_classes, savefig=save_conf_tbl[:-4] + '.png', normalize=True)

print(f'  {datetime.strftime(datetime.now(), fmt)}: finished in {datetime.now() - start}')
print('  Done ;-)')
